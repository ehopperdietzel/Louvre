<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WaylandPlus: zxdg_toplevel_v6_interface Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">WaylandPlus<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">C++ library to create desktop style compositors.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structzxdg__toplevel__v6__interface.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structzxdg__toplevel__v6__interface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">zxdg_toplevel_v6_interface Struct Reference<div class="ingroups"><a class="el" href="group__iface__zxdg__toplevel__v6.html">The zxdg_toplevel_v6 interface</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="xdg-shell-unstable-v6_8h_source.html">xdg-shell-unstable-v6.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae5e48d2e3138b4f082892f399bbd0001"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzxdg__toplevel__v6__interface.html#ae5e48d2e3138b4f082892f399bbd0001">destroy</a> )(struct wl_client *client, struct wl_resource *resource)</td></tr>
<tr class="separator:ae5e48d2e3138b4f082892f399bbd0001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253c3a3b9e280330c225e073d63ff13b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzxdg__toplevel__v6__interface.html#a253c3a3b9e280330c225e073d63ff13b">set_parent</a> )(struct wl_client *client, struct wl_resource *resource, struct wl_resource *parent)</td></tr>
<tr class="separator:a253c3a3b9e280330c225e073d63ff13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1977d0d7c58f3c341c674e97f30ad0ee"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzxdg__toplevel__v6__interface.html#a1977d0d7c58f3c341c674e97f30ad0ee">set_title</a> )(struct wl_client *client, struct wl_resource *resource, const char *title)</td></tr>
<tr class="separator:a1977d0d7c58f3c341c674e97f30ad0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e98ad0f942f098daac14db62bbe708"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzxdg__toplevel__v6__interface.html#a89e98ad0f942f098daac14db62bbe708">set_app_id</a> )(struct wl_client *client, struct wl_resource *resource, const char *app_id)</td></tr>
<tr class="separator:a89e98ad0f942f098daac14db62bbe708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade932a1d8b28717380da82ae7b59ead4"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzxdg__toplevel__v6__interface.html#ade932a1d8b28717380da82ae7b59ead4">show_window_menu</a> )(struct wl_client *client, struct wl_resource *resource, struct wl_resource *seat, uint32_t serial, int32_t x, int32_t y)</td></tr>
<tr class="separator:ade932a1d8b28717380da82ae7b59ead4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cba9fd1ccf4bb4f543baeaf72929f0"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzxdg__toplevel__v6__interface.html#ae9cba9fd1ccf4bb4f543baeaf72929f0">move</a> )(struct wl_client *client, struct wl_resource *resource, struct wl_resource *seat, uint32_t serial)</td></tr>
<tr class="separator:ae9cba9fd1ccf4bb4f543baeaf72929f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae337f13dd39f4a37b41604b3c879adc"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzxdg__toplevel__v6__interface.html#aae337f13dd39f4a37b41604b3c879adc">resize</a> )(struct wl_client *client, struct wl_resource *resource, struct wl_resource *seat, uint32_t serial, uint32_t edges)</td></tr>
<tr class="separator:aae337f13dd39f4a37b41604b3c879adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee9974efefee2c0ed41cbd62e0027e5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzxdg__toplevel__v6__interface.html#a5ee9974efefee2c0ed41cbd62e0027e5">set_max_size</a> )(struct wl_client *client, struct wl_resource *resource, int32_t width, int32_t height)</td></tr>
<tr class="separator:a5ee9974efefee2c0ed41cbd62e0027e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaad44b2131aa94f67cc30c508088512"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzxdg__toplevel__v6__interface.html#acaad44b2131aa94f67cc30c508088512">set_min_size</a> )(struct wl_client *client, struct wl_resource *resource, int32_t width, int32_t height)</td></tr>
<tr class="separator:acaad44b2131aa94f67cc30c508088512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3aaa379542d93ebb9840acc1624959"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzxdg__toplevel__v6__interface.html#a7b3aaa379542d93ebb9840acc1624959">set_maximized</a> )(struct wl_client *client, struct wl_resource *resource)</td></tr>
<tr class="separator:a7b3aaa379542d93ebb9840acc1624959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc1814c8ba9dce8e3aac67c04581bab"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzxdg__toplevel__v6__interface.html#a0dc1814c8ba9dce8e3aac67c04581bab">unset_maximized</a> )(struct wl_client *client, struct wl_resource *resource)</td></tr>
<tr class="separator:a0dc1814c8ba9dce8e3aac67c04581bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77b60c95bb7c89350bd54f71bd26620"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzxdg__toplevel__v6__interface.html#ac77b60c95bb7c89350bd54f71bd26620">set_fullscreen</a> )(struct wl_client *client, struct wl_resource *resource, struct wl_resource *output)</td></tr>
<tr class="separator:ac77b60c95bb7c89350bd54f71bd26620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e8fde75776f9f396cfa2b0931184ea"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzxdg__toplevel__v6__interface.html#ad5e8fde75776f9f396cfa2b0931184ea">unset_fullscreen</a> )(struct wl_client *client, struct wl_resource *resource)</td></tr>
<tr class="separator:ad5e8fde75776f9f396cfa2b0931184ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f477e3dcc4d7be2ce4d04d77597d162"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzxdg__toplevel__v6__interface.html#a3f477e3dcc4d7be2ce4d04d77597d162">set_minimized</a> )(struct wl_client *client, struct wl_resource *resource)</td></tr>
<tr class="separator:a3f477e3dcc4d7be2ce4d04d77597d162"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae5e48d2e3138b4f082892f399bbd0001" name="ae5e48d2e3138b4f082892f399bbd0001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e48d2e3138b4f082892f399bbd0001">&#9670;&nbsp;</a></span>destroy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* zxdg_toplevel_v6_interface::destroy) (struct wl_client *client, struct wl_resource *resource)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >destroy the xdg_toplevel</p>
<p >Unmap and destroy the window. The window will be effectively hidden from the user's point of view, and all state like maximization, fullscreen, and so on, will be lost. </p>

</div>
</div>
<a id="ae9cba9fd1ccf4bb4f543baeaf72929f0" name="ae9cba9fd1ccf4bb4f543baeaf72929f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9cba9fd1ccf4bb4f543baeaf72929f0">&#9670;&nbsp;</a></span>move</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* zxdg_toplevel_v6_interface::move) (struct wl_client *client, struct wl_resource *resource, struct wl_resource *seat, uint32_t serial)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >start an interactive move</p>
<p >Start an interactive, user-driven move of the surface.</p>
<p >This request must be used in response to some sort of user action like a button press, key press, or touch down event. The passed serial is used to determine the type of interactive move (touch, pointer, etc).</p>
<p >The server may ignore move requests depending on the state of the surface (e.g. fullscreen or maximized), or if the passed serial is no longer valid.</p>
<p >If triggered, the surface will lose the focus of the device (wl_pointer, wl_touch, etc) used for the move. It is up to the compositor to visually indicate that the move is taking place, such as updating a pointer cursor, during the move. There is no guarantee that the device focus will return when the move is completed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seat</td><td>the wl_seat of the user event </td></tr>
    <tr><td class="paramname">serial</td><td>the serial of the user event </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae337f13dd39f4a37b41604b3c879adc" name="aae337f13dd39f4a37b41604b3c879adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae337f13dd39f4a37b41604b3c879adc">&#9670;&nbsp;</a></span>resize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* zxdg_toplevel_v6_interface::resize) (struct wl_client *client, struct wl_resource *resource, struct wl_resource *seat, uint32_t serial, uint32_t edges)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >start an interactive resize</p>
<p >Start a user-driven, interactive resize of the surface.</p>
<p >This request must be used in response to some sort of user action like a button press, key press, or touch down event. The passed serial is used to determine the type of interactive resize (touch, pointer, etc).</p>
<p >The server may ignore resize requests depending on the state of the surface (e.g. fullscreen or maximized).</p>
<p >If triggered, the client will receive configure events with the "resize" state enum value and the expected sizes. See the "resize" enum value for more details about what is required. The client must also acknowledge configure events using "ack_configure". After the resize is completed, the client will receive another "configure" event without the resize state.</p>
<p >If triggered, the surface also will lose the focus of the device (wl_pointer, wl_touch, etc) used for the resize. It is up to the compositor to visually indicate that the resize is taking place, such as updating a pointer cursor, during the resize. There is no guarantee that the device focus will return when the resize is completed.</p>
<p >The edges parameter specifies how the surface should be resized, and is one of the values of the resize_edge enum. The compositor may use this information to update the surface position for example when dragging the top left corner. The compositor may also use this information to adapt its behavior, e.g. choose an appropriate cursor image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seat</td><td>the wl_seat of the user event </td></tr>
    <tr><td class="paramname">serial</td><td>the serial of the user event </td></tr>
    <tr><td class="paramname">edges</td><td>which edge or corner is being dragged </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89e98ad0f942f098daac14db62bbe708" name="a89e98ad0f942f098daac14db62bbe708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e98ad0f942f098daac14db62bbe708">&#9670;&nbsp;</a></span>set_app_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* zxdg_toplevel_v6_interface::set_app_id) (struct wl_client *client, struct wl_resource *resource, const char *app_id)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >set application ID</p>
<p >Set an application identifier for the surface.</p>
<p >The app ID identifies the general class of applications to which the surface belongs. The compositor can use this to group multiple surfaces together, or to determine how to launch a new application.</p>
<p >For D-Bus activatable applications, the app ID is used as the D-Bus service name.</p>
<p >The compositor shell will try to group application surfaces together by their app ID. As a best practice, it is suggested to select app ID's that match the basename of the application's .desktop file. For example, "org.freedesktop.FooViewer" where the .desktop file is "org.freedesktop.FooViewer.desktop".</p>
<p >See the desktop-entry specification [0] for more details on application identifiers and how they relate to well-known D-Bus names and .desktop files.</p>
<p >[0] <a href="http://standards.freedesktop.org/desktop-entry-spec/">http://standards.freedesktop.org/desktop-entry-spec/</a> </p>

</div>
</div>
<a id="ac77b60c95bb7c89350bd54f71bd26620" name="ac77b60c95bb7c89350bd54f71bd26620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77b60c95bb7c89350bd54f71bd26620">&#9670;&nbsp;</a></span>set_fullscreen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* zxdg_toplevel_v6_interface::set_fullscreen) (struct wl_client *client, struct wl_resource *resource, struct wl_resource *output)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >set the window as fullscreen on a monitor</p>
<p >Make the surface fullscreen.</p>
<p >You can specify an output that you would prefer to be fullscreen. If this value is NULL, it's up to the compositor to choose which display will be used to map this surface.</p>
<p >If the surface doesn't cover the whole output, the compositor will position the surface in the center of the output and compensate with black borders filling the rest of the output. </p>

</div>
</div>
<a id="a5ee9974efefee2c0ed41cbd62e0027e5" name="a5ee9974efefee2c0ed41cbd62e0027e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee9974efefee2c0ed41cbd62e0027e5">&#9670;&nbsp;</a></span>set_max_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* zxdg_toplevel_v6_interface::set_max_size) (struct wl_client *client, struct wl_resource *resource, int32_t width, int32_t height)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >set the maximum size</p>
<p >Set a maximum size for the window.</p>
<p >The client can specify a maximum size so that the compositor does not try to configure the window beyond this size.</p>
<p >The width and height arguments are in window geometry coordinates. See xdg_surface.set_window_geometry.</p>
<p >Values set in this way are double-buffered. They will get applied on the next commit.</p>
<p >The compositor can use this information to allow or disallow different states like maximize or fullscreen and draw accurate animations.</p>
<p >Similarly, a tiling window manager may use this information to place and resize client windows in a more effective way.</p>
<p >The client should not rely on the compositor to obey the maximum size. The compositor may decide to ignore the values set by the client and request a larger size.</p>
<p >If never set, or a value of zero in the request, means that the client has no expected maximum size in the given dimension. As a result, a client wishing to reset the maximum size to an unspecified state can use zero for width and height in the request.</p>
<p >Requesting a maximum size to be smaller than the minimum size of a surface is illegal and will result in a protocol error.</p>
<p >The width and height must be greater than or equal to zero. Using strictly negative values for width and height will result in a protocol error. </p>

</div>
</div>
<a id="a7b3aaa379542d93ebb9840acc1624959" name="a7b3aaa379542d93ebb9840acc1624959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3aaa379542d93ebb9840acc1624959">&#9670;&nbsp;</a></span>set_maximized</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* zxdg_toplevel_v6_interface::set_maximized) (struct wl_client *client, struct wl_resource *resource)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >maximize the window</p>
<p >Maximize the surface.</p>
<p >After requesting that the surface should be maximized, the compositor will respond by emitting a configure event with the "maximized" state and the required window geometry. The client should then update its content, drawing it in a maximized state, i.e. without shadow or other decoration outside of the window geometry. The client must also acknowledge the configure when committing the new content (see ack_configure).</p>
<p >It is up to the compositor to decide how and where to maximize the surface, for example which output and what region of the screen should be used.</p>
<p >If the surface was already maximized, the compositor will still emit a configure event with the "maximized" state. </p>

</div>
</div>
<a id="acaad44b2131aa94f67cc30c508088512" name="acaad44b2131aa94f67cc30c508088512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaad44b2131aa94f67cc30c508088512">&#9670;&nbsp;</a></span>set_min_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* zxdg_toplevel_v6_interface::set_min_size) (struct wl_client *client, struct wl_resource *resource, int32_t width, int32_t height)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >set the minimum size</p>
<p >Set a minimum size for the window.</p>
<p >The client can specify a minimum size so that the compositor does not try to configure the window below this size.</p>
<p >The width and height arguments are in window geometry coordinates. See xdg_surface.set_window_geometry.</p>
<p >Values set in this way are double-buffered. They will get applied on the next commit.</p>
<p >The compositor can use this information to allow or disallow different states like maximize or fullscreen and draw accurate animations.</p>
<p >Similarly, a tiling window manager may use this information to place and resize client windows in a more effective way.</p>
<p >The client should not rely on the compositor to obey the minimum size. The compositor may decide to ignore the values set by the client and request a smaller size.</p>
<p >If never set, or a value of zero in the request, means that the client has no expected minimum size in the given dimension. As a result, a client wishing to reset the minimum size to an unspecified state can use zero for width and height in the request.</p>
<p >Requesting a minimum size to be larger than the maximum size of a surface is illegal and will result in a protocol error.</p>
<p >The width and height must be greater than or equal to zero. Using strictly negative values for width and height will result in a protocol error. </p>

</div>
</div>
<a id="a3f477e3dcc4d7be2ce4d04d77597d162" name="a3f477e3dcc4d7be2ce4d04d77597d162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f477e3dcc4d7be2ce4d04d77597d162">&#9670;&nbsp;</a></span>set_minimized</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* zxdg_toplevel_v6_interface::set_minimized) (struct wl_client *client, struct wl_resource *resource)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >set the window as minimized</p>
<p >Request that the compositor minimize your surface. There is no way to know if the surface is currently minimized, nor is there any way to unset minimization on this surface.</p>
<p >If you are looking to throttle redrawing when minimized, please instead use the wl_surface.frame event for this, as this will also work with live previews on windows in Alt-Tab, Expose or similar compositor features. </p>

</div>
</div>
<a id="a253c3a3b9e280330c225e073d63ff13b" name="a253c3a3b9e280330c225e073d63ff13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253c3a3b9e280330c225e073d63ff13b">&#9670;&nbsp;</a></span>set_parent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* zxdg_toplevel_v6_interface::set_parent) (struct wl_client *client, struct wl_resource *resource, struct wl_resource *parent)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >set the parent of this surface</p>
<p >Set the "parent" of this surface. This window should be stacked above a parent. The parent surface must be mapped as long as this surface is mapped.</p>
<p >Parent windows should be set on dialogs, toolboxes, or other "auxiliary" surfaces, so that the parent is raised when the dialog is raised. </p>

</div>
</div>
<a id="a1977d0d7c58f3c341c674e97f30ad0ee" name="a1977d0d7c58f3c341c674e97f30ad0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1977d0d7c58f3c341c674e97f30ad0ee">&#9670;&nbsp;</a></span>set_title</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* zxdg_toplevel_v6_interface::set_title) (struct wl_client *client, struct wl_resource *resource, const char *title)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >set surface title</p>
<p >Set a short title for the surface.</p>
<p >This string may be used to identify the surface in a task bar, window list, or other user interface elements provided by the compositor.</p>
<p >The string must be encoded in UTF-8. </p>

</div>
</div>
<a id="ade932a1d8b28717380da82ae7b59ead4" name="ade932a1d8b28717380da82ae7b59ead4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade932a1d8b28717380da82ae7b59ead4">&#9670;&nbsp;</a></span>show_window_menu</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* zxdg_toplevel_v6_interface::show_window_menu) (struct wl_client *client, struct wl_resource *resource, struct wl_resource *seat, uint32_t serial, int32_t x, int32_t y)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >show the window menu</p>
<p >Clients implementing client-side decorations might want to show a context menu when right-clicking on the decorations, giving the user a menu that they can use to maximize or minimize the window.</p>
<p >This request asks the compositor to pop up such a window menu at the given position, relative to the local surface coordinates of the parent surface. There are no guarantees as to what menu items the window menu contains.</p>
<p >This request must be used in response to some sort of user action like a button press, key press, or touch down event. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seat</td><td>the wl_seat of the user event </td></tr>
    <tr><td class="paramname">serial</td><td>the serial of the user event </td></tr>
    <tr><td class="paramname">x</td><td>the x position to pop up the window menu at </td></tr>
    <tr><td class="paramname">y</td><td>the y position to pop up the window menu at </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5e8fde75776f9f396cfa2b0931184ea" name="ad5e8fde75776f9f396cfa2b0931184ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e8fde75776f9f396cfa2b0931184ea">&#9670;&nbsp;</a></span>unset_fullscreen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* zxdg_toplevel_v6_interface::unset_fullscreen) (struct wl_client *client, struct wl_resource *resource)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0dc1814c8ba9dce8e3aac67c04581bab" name="a0dc1814c8ba9dce8e3aac67c04581bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc1814c8ba9dce8e3aac67c04581bab">&#9670;&nbsp;</a></span>unset_maximized</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* zxdg_toplevel_v6_interface::unset_maximized) (struct wl_client *client, struct wl_resource *resource)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >unmaximize the window</p>
<p >Unmaximize the surface.</p>
<p >After requesting that the surface should be unmaximized, the compositor will respond by emitting a configure event without the "maximized" state. If available, the compositor will include the window geometry dimensions the window had prior to being maximized in the configure request. The client must then update its content, drawing it in a regular state, i.e. potentially with shadow, etc. The client must also acknowledge the configure when committing the new content (see ack_configure).</p>
<p >It is up to the compositor to position the surface after it was unmaximized; usually the position the surface had before maximizing, if applicable.</p>
<p >If the surface was already not maximized, the compositor will still emit a configure event without the "maximized" state. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/eduardo/Escritorio/Projects/WaylandPlus/src/Wayland++/globals/XdgShell/<a class="el" href="xdg-shell-unstable-v6_8h_source.html">xdg-shell-unstable-v6.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structzxdg__toplevel__v6__interface.html">zxdg_toplevel_v6_interface</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
